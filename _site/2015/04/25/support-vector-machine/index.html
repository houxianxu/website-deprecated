<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Support Vector Machine</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="From Coal Mining to Data Mining">
    <link rel="canonical" href="http://houxianxu.github.io/2015/04/25/support-vector-machine/">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Xianxu Hou's blog posts" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-61586501-1', 'auto');
      ga('send', 'pageview');
    </script>

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <div style="float:left; margin-top:10px; margin-right:10px;">
      <img src="/assets/avatar_Xianxu Hou.png" width="40">
    </a>
    </div>

    <a class="site-title" href="/">Xianxu Hou's blog</a>
    
    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="/about/">About</a>
        
          
        
          
        
          
        
          
        
      </div>
    </nav>
  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Support Vector Machine</h1>
    <p class="meta">Apr 25, 2015</p>
  </header>

  <article class="post-content">
  <p>Support vector machine (SVM) is often considered one of the best “out of the box” classifiers, and in this post I try to explain how we can come up with this alogrithm from scratch.</p>

<p>I also implement the SMV for image classification with <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10 dataset</a> by Python (numpy). <a href="http://houxianxu.github.io/implementation/SVM.html">This</a> is for mutli-classification by using SVM loss.</p>

<h2 id="problem-setting">1. Problem setting</h2>
<p>Classification problem is to classify different objects into different categories. For simplicity, we just focus on <strong>binary classification</strong> that y can take two values 1 or -1 (indicating two classes), and we firstly assume the two classes are linearly separable. After all, it is reasonable to solve problems from simple to complex.</p>

<h2 id="basic-idea-what-we-have-known">2. Basic idea (What we have known)</h2>
<p>If the data is linearly separable, our goal is to find the such a line <script type="math/tex">f(x) = w^Tx + b = 0</script> (2-dimension) that divides the plane into 2 parts and each part represent one class (see following figure). If the data is represented in high dimension say N-dimension, what we need to do is to find a hyperplane <script type="math/tex">w^Tx + b = 0</script> which is subspace with dimension (N-1)dimension. So if <script type="math/tex">w^Tx + b = 0</script>, the label <script type="math/tex">y = 1</script>, otherwise <script type="math/tex">y = -1</script>. However, the problem is that in fact there exists infinite such hyperplanes if the data can be perfectly linearly separated, because a given separating hyperplane can be shifted a tiny bit up or down, or rotated without coming into contact with any of the observations (the line 1, 2 and 3 in the following figure) . Of course we can randomly choose a separating line.</p>

<!-- ![Scatter Plot of Two variables](http://houxianxu.github.io/images/SVM/1.png "linearly separable") -->
<center><img src="/images/SVM/1.png" width="80%" /></center>

<h2 id="maximal-margin-classifier">3. Maximal Margin Classifier</h2>
<p><strong>Can we do better?</strong></p>

<p>Is that possible for us to choose the even “best” line or hyperplane from the infinit possible separating hyperplanes? So the next question is how to define the “best” hyperplane. Because the final goal is trying to use the hyperplane as decision boundary to distinguish the two classes, so we can choose the hyperplane which can make the distinction more obvious. Intuitively the separating hyperplane should be farthest from the training observations, that’s to say, the distance between the nearest observation and the hyperplane should be maximized. This distance is usually called margin and the corresponding classifier is known as maximal margin classifier, and the separating hyperplane has the farthest minimum distance to the training observations. Take the above figure for example, line 3 is better than line 1 and 2.</p>

<p>From figure below, we can see that there are 3 training points having equal distance from the maximal margin line and the two dash lines indicate the width of margin. These 3 observations are known as <strong>support vectors</strong>. Since these points can interpreted as n-1 dimension vectors and define the maximal margin, in other words, these vectors can “support” the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hyperplane would move as well. What’s more, the maximal margin hyperplane is only depends on the support vectors, not other observation.</p>

<!-- ![Support Vector](http://houxianxu.github.io/images/SVM/2.png "support vector") -->
<center><img src="/images/SVM/2.png" width="80%" /></center>

<p><strong>Calculate the maximal margin</strong>
In order to calculate the maximal margin, we should figure out how to calculate the geometric margin which is the distance from a point to a line or hyperplane. As following figure, the point at A representing the input <script type="math/tex">x^{(i)}</script> of some training example. Its distance to the decision boundary (a line with (w, b)) is <script type="math/tex">\gamma^{(i)}</script>, is given by the line segment AB. And the distance <script type="math/tex">\gamma^{(i)}</script> can be calculate in the following way:</p>

<!-- ![geometric margin](http://houxianxu.github.io/images/SVM/3.png "geometric margin") -->
<center><img src="/images/SVM/3.png" width="80%" /></center>

<p>vector <script type="math/tex">BA = x_A - x_B</script>, unit vector is <script type="math/tex">w/\|w\|</script>, so the point B is given by <script type="math/tex">x^{(i)} - \gamma^{(i)} w/\|w\|</script>. And point B is on the decision boundary <script type="math/tex">w^T x + b</script>, therefore</p>

<script type="math/tex; mode=display">w^T \big(x^{(i)} - \gamma^{(i)} \frac{w}{\|w\|}\big) + b = 0</script>

<p>Then solving <script type="math/tex">\gamma^{(i)}</script> yields:</p>

<script type="math/tex; mode=display">\gamma^{(i)} = \frac{w^T x^{(i)} + b}{\|w\|}</script>

<p>Using bias trick to represent the two parameters <strong>w</strong> and <strong>b</strong> as one, i.e. set <script type="math/tex">x_0 = 1</script> and add <script type="math/tex">w_0</script> to weights vector <strong>w</strong>.
Then we get:</p>

<script type="math/tex; mode=display">\gamma^{(i)} = \frac{w^T x^{(i)}}{\|w\|}</script>

<p>Therefore based on a set of m training observations <script type="math/tex">x_1, x_2, ..., x_m</script> and associated class labels <script type="math/tex">y_1, y_2, ..., y_m \in \big\{1, -1\big\}</script>, the assumption that the training set is linearly separable, the maximal margin line or hyperplane is the solution to the optimization problem.</p>

<script type="math/tex; mode=display">Maximize_{w, M} \:\:\: \frac{M}{\|w\|}  \:\:\:......... (1)</script>

<p>Subject to</p>

<script type="math/tex; mode=display">y^{(i)} (W^Tx^{(i)}) = M \:\: \forall i = 1, 2, ..., m \:\:\:......... (2)</script>

<p>The constrains (2) guarantees that each observation will be on the correct side of the decision boundary and the value of <script type="math/tex">y^{(i)} (W^Tx^{(i)})</script> is at least M, provided that M is positive. In addition, the margin is given by <script type="math/tex">\frac{w^T x^{(i)}}{\|w\|}</script>, the objective function <script type="math/tex">(1) \frac{M}{\|w\|}</script> ensures that each observation has at least a distance <script type="math/tex">\frac{M}{\|w\|}</script> from the hyperplane or decision boundary. Hence, the optimization problem choose <strong>w</strong> and <strong>M</strong> to maximize <script type="math/tex">\frac{M}{\|w\|}</script>.</p>

<p><strong>Solve the optimization problem</strong></p>

<p>If we could solve the optimization problem above efficiently, then we would be done. In fact the optimization problem above is very difficult because we have a nasty objective <script type="math/tex">\frac{M}{\|w\|}</script> function, which is non-convex. So can we do better?</p>

<p>The final goal is to find the decision boundary <script type="math/tex">w^T x = 0</script>, so multiplying w by some constant can affect the margin but doesn’t change the decision boundary. Therefore, we can set the value of <script type="math/tex">w^T x_0</script> for the nearest point to be 1, i.e., <script type="math/tex">M = 1</script>. Additionally maximize <script type="math/tex">\frac{1}{\|w\|}</script> is the same to minimize |w|, again is the same thing as minimizing <script type="math/tex">\|w\|^2</script>. Therefore we have the following optimization problem:</p>

<script type="math/tex; mode=display">Minimize_w \:\:\: \frac{1}{2}\|w\|^2  \:\:\:......... (1)</script>

<p>Subject to</p>

<script type="math/tex; mode=display">y^{(i)} (W^Tx^{(i)}) = 1 \:\: \forall i = 1, 2, ..., m \:\:\:......... (2)</script>

<p>The new version of optimization problem can be efficiently solved, because the objective function is a convex quadratic function and all the constrains are linear. The problem can be solved by Quadratic Program (QR) software such as <a href="http://cvxopt.org">CVXOPT</a> for Python.</p>

<h2 id="dual-form-kernel-and-support-vector-machine">4 Dual Form, Kernel and Support Vector Machine</h2>
<p>According to <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes3.pdf">Lagrange duality</a>, we can get the dual form of the above optimization problem.</p>

<script type="math/tex; mode=display">Maximize_{\alpha} \:\: W(\alpha) = \sum_{(i=1)}^m \alpha_i - \frac{1}{2} \sum_{i, j=1}^m y^{(i)}y^{(j)} \alpha_i \alpha_j \langle x^{(i)}, x^{(j)}\rangle</script>

<p>Subject to</p>

<script type="math/tex; mode=display">\alpha_i \geq 0, \forall \: i = 1, 2, ..., m</script>

<script type="math/tex; mode=display">\sum_{i=1}^m \alpha_i y^{(i)} = 0</script>

<p>The <script type="math/tex">\langle x^{(i)}, x^{(j)}\rangle = \big(x^{(i)}\big)^T x^{(j)}</script>, and the original <strong>w</strong> = <script type="math/tex">\sum_i^m \alpha_i y^{(i)}x^{(i)}</script>. And the decision boundary becomes</p>

<script type="math/tex; mode=display">f(x) = w^T + b = \big(\sum_i^m\alpha_i y^{(i)}x^{(i)}\big)^T x + b = \sum_i^m\alpha_i y^{(i)} \langle x^{(i)}, x\rangle + b = 0</script>

<p>Therefore, we can solve the dual problem (optimizing the <script type="math/tex">\alpha</script>) in lieu of solving the primal optimization problem. Specifically in order to ake a prediction, all we need to do is to calculate the inner product between the new point x and each of the training samples <script type="math/tex">x_i</script>. However, it turns out that <script type="math/tex">\alpha_i's</script> will be zero except for the support vectors, so we only need to find the inner products between x and support vectors to make prediction.</p>

<p>So far, what we’ve got is just a linear classifier or linear boundary <script type="math/tex">w^T x + b = 0</script>. And if we want a non-linear boundary, what we can do? Intuitively we can use non-linear items in the boundary functions such as <script type="math/tex">wx^2</script> and <script type="math/tex">wx^3</script>. In general we need to use a non-linear function (g(x)) to transfer the original input x to a new value g(x) which are passed into learning algorithm. These new quantities are often called <strong>features</strong> and the original input x can be called <strong>attributes</strong>. Usually people use <script type="math/tex">\phi(x)</script> the <strong>feature mapping</strong>, which maps from attributes to features. Here is a example:</p>

<script type="math/tex; mode=display">\phi(x) =  \begin{bmatrix} x\\ x^2 \\ x^3 \end{bmatrix}</script>

<p>Then the decision boundary is <script type="math/tex">f(x) = w_1 x + w_2 x^2 + w_3 x^3 + b = 0</script></p>

<p>We should notice that the above decision boundary is a non-linear in 2-dimension space, i.e., <script type="math/tex">w_1 x + w_2 x^2 + w_3 y + b = 0</script>, however we get a plane in a 3-dimension space <script type="math/tex">w_1 x + w_2 y + w_3 z + b = 0</script>, which we can be solved by using maximal classifier discussed above.</p>

<p>Thus, rather than using the original input attributes x, we may instead use the features <script type="math/tex">\phi(x)</script>. To do so, we just need to change the previous algorithm by replacing x with <script type="math/tex">\phi(x)</script>.</p>

<p>The next question is how to choose the feature mapping, and we could choose arbitrary non-linear functions to compute features <script type="math/tex">\phi(x)</script>, and then calculate the inner product of <script type="math/tex">\phi(x)^T \phi(z)</script>. However, it may be very expensive to compute the features and the inner product when features are high dimension vectors.</p>

<p>One important property of the dual form is that the algorithm can be written entirely in terms of inner product <script type="math/tex">\langle x, z\rangle</script>, which means that we can replace the inner product with <script type="math/tex">\langle \phi(x), \phi(z) \rangle</script>. And we define the <strong>Kernel</strong> as following:</p>

<script type="math/tex; mode=display">K(x, z) = \phi(x)^T \phi(z) = \langle \phi(x), \phi(z) \rangle</script>

<p>The goal is to compute the <script type="math/tex">K(x, z)</script>, and the interesting is that <script type="math/tex">K(x, z)</script> may be not expensive to calculate because we don’t firsly need to compute the <script type="math/tex">\phi(x)</script> and then calculate the inner product (see following example).</p>

<p>Suppose the <script type="math/tex">x, z \in \mathbb{R}^n</script> and we can can construct the Kernel:</p>

<script type="math/tex; mode=display">K(x, z) = (x^T z)^2</script>

<p>We can rewrite it as following</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
     \begin{split} 
     K(x, z)
     &= (x^T z)^2 \\
     &= \big(\sum_{i=1}^n x_i z_i\big) \big(\sum_{j=1}^n x_j z_j) \\
     &= \sum_{i=1}^n \sum_{j=1}^n x_i x_j z_i z_j \\
     &= \sum_{i, j=1}^n (x_i x_j)(z_i z_j)
    \end{split}
    \end{equation} %]]></script>

<p>We can see <script type="math/tex">K(x, z) = \phi(x)^T \phi(z)</script>, where the <script type="math/tex">\phi(x)</script> is shown below (take n = 3)</p>

<script type="math/tex; mode=display">\phi(x) = \begin{bmatrix} x_1x_1\\ x_1x_2 \\x_1x_3\\x_2x_1\\x_2x_2\\x_2x_3\\x_3x_1\\x_3x_2\\x_3x_3 \end{bmatrix}</script>

<p>So we can efficiently calculate the <script type="math/tex">K(x, z) = (x^T z)^2</script> in <script type="math/tex">O(n)</script> because of n-dimension input attributes x. However, it takes <script type="math/tex">O(n^2)</script> to calculate <script type="math/tex">\phi(x)</script>.</p>

<p>In general, we can also use <script type="math/tex">K(x, z) = (X^T z + c)^d</script> to achieve feature mapping, which is known as <strong>ploynomial kernel</strong> of degree <strong>d</strong>. This kernel essentially amount to fitting a support vector classifier in a higher-dimensional space involving polynomials of degree d, which leads to a much more flexible decision boundary. Notice that though working in a very high dimension space, we only need <script type="math/tex">O(n)</script> time to compute the K(x, z) because we never need to explicitly represent feature vectors in the very high dimensional feature space.</p>

<p>Another popular choice is <strong>Gaussian Kernel</strong> or <strong>Radial Kernel</strong>:</p>

<script type="math/tex; mode=display">K(x, z) = exp \big( - \frac{(x-z)^2} {2 \sigma^2} \big)</script>

<p>We can use Taylor expansion to expand the Gaussian Kernel (<script type="math/tex">e^x = \sum_{n=0}^\infty \frac {x^n} {n!}</script>), and we can see that the feature vector that corresponds to the Gaussian kernel has infinite dimensionality, and the feature space is implicit.</p>

<p>How does the Kernel work? One intuition is to think of <script type="math/tex">K(x, z)</script> as a measurement of how similar are <script type="math/tex">\phi(x)</script> and <script type="math/tex">\phi(z)</script>, or of how similar are x and z. If  <script type="math/tex">\phi(x)</script> and  <script type="math/tex">\phi(z)</script> are close to each other, then <script type="math/tex">K(x, z) = \phi(x)^T \phi(z)</script> is expected to large, otherwise <script type="math/tex">\phi(x)</script> and  <script type="math/tex">\phi(z)</script> are far apart, then <script type="math/tex">K(x, z)</script> is small. Recall that we use the sign of</p>

<script type="math/tex; mode=display">f(x) = w^T + b =\sum_i^m\alpha_i y^{(i)} \langle x^{(i)}, x\rangle + b =\sum_i^m\alpha_i y^{(i)} \langle \phi(x^{(i)}), \phi(x)\rangle + b</script>

<p>for prediction. Look at Gaussian Kernel, if training observations that are far from test observation x will play essentially little role in the predicted class label for x. This means that Gaussian Kernel has a local hehavior, in the sense that only nearby training observations have a big effect on a class label for test observation.</p>

<p>The <strong>Support Vector Machine</strong> is an extension of the support vector classifier that results from enlarging the feature space in a specific way, using kernels.</p>

<h2 id="the-non-separable-case">5 The Non-separable Case</h2>
<p>The SVMs work very well for classification if a separating hyperplane exists, however, we will get stuck when the data is overlapped and non-separable because there is no max margin. So we can extend the separating hyperplane in order to almost separate the classes based on soft margin. We instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. We reformulate the optimization problem as follows:</p>

<script type="math/tex; mode=display">Minimize_w \:\:\: \frac{1}{2}\|w\|^2 + C \sum_{i=1}^m \zeta_i</script>

<p>Subject to</p>

<script type="math/tex; mode=display">y^{(i)} (W^Tx^{(i)}) = 1 -\zeta_i \:\: \forall i = 1, 2, ..., m</script>

<p>Thus, we permit the observation to be on the incorrect side of the margin, or even the incorrect side of the hyperplane (<script type="math/tex">% <![CDATA[
1-\zeta_i < 0 %]]></script>), and we pay a cost of the objective function being increased by <script type="math/tex">C\zeta_i</script>. The big number C ensuring that <script type="math/tex">\zeta_i</script> is small and most examples have at least soft max margin.</p>

<p>And the dual form is as follows:</p>

<script type="math/tex; mode=display">Maximize_{\alpha} \:\: W(\alpha) = \sum_{(i=1)}^m \alpha_i - \frac{1}{2} \sum_{i, j=1}^m y^{(i)}y^{(j)} \alpha_i \alpha_j \langle x^{(i)}, x^{(j)}\rangle</script>

<p>Subject to</p>

<script type="math/tex; mode=display">0 \leq \alpha_i \geq C, \forall \: i = 1, 2, ..., m</script>

<script type="math/tex; mode=display">\sum_{i=1}^m \alpha_i y^{(i)} = 0</script>

<p>Above is the basic idea of Support Vector Machine (SVM), all that remains is to to find a algorithm for solving the dual problem. The SMO (sequential minimal optimization) algorithm give an efficient way to solve the dual problem. You can find the details <a href="http://cs229.stanford.edu/materials/smo.pdf">here</a>.</p>

<h2 id="multiclass-classification">6 Multiclass classification</h2>
<p>We need to generalize to the multiple class case, that’s to say, the value of y is not binary any more, instead y can equal to 0, 1, 2, …, k.</p>

<p>####Transfer multi-class classification into binary classification problem</p>

<p>We need change multiple classes into two classes, and the idea is to construct several logistic classifier for each class. We set the value of y (label) of one class to 1, and 0 for other classes. Thus, if we have K classes, we build K SVM and use it for prediction. The idea is the same as use <a href="http://houxianxu.github.io/logistic-softmax-regression/#multiclass">logistic regression</a> for multi-classfication.
<!-- ![One vs all](http://houxianxu.github.io/images/logisticRegression/4.png "Figure 4") --></p>
<center><img src="/images/logisticRegression/4.png" width="80%" /></center>

<h4 id="multiclass-support-vector-machine-loss">Multiclass Support Vector Machine loss</h4>
<p>Similar to <a href="http://houxianxu.github.io/logistic-softmax-regression/">softmax</a>, For mutilple classes problems (K categoires), it is possible to establish a mapping function for each class. We can simply use a linear mapping for all classes (K mapping function):</p>

<script type="math/tex; mode=display">f(x^{(i)}, W, b) = Wx^{(i)} + b =f(x^{(i)}, W) = Wx^{(i)} \:(bias \: trick)</script>

<p>Intuitively we wish that the correct class has a score that is higher than the scores of incorrect classes. Thus, we can predict the test observation as the class with the highest score. Next we should find a loss function to optimize the parameters.</p>

<p>For sample <script type="math/tex">x_i</script>, the vector <script type="math/tex">f(x_i, W)</script> is the scores for all the classes, <script type="math/tex">y_i</script> is the correct class and <script type="math/tex">f(x_i, W)_{y_i}</script> is the score corresponding to the correct class for <script type="math/tex">x_i</script>. The score for the <script type="math/tex">j^{th}</script> class is <script type="math/tex">f(x_i, W)_j</script>. The multiclass SVM loss for the <script type="math/tex">i^{th}</script> sample is as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
     \begin{split} 
		L_i &= \sum_{j\neq y_i} max(0, f(x_i, W)_j - f(x_i, W)_{y_j} + \Delta) \\
	   		&= \sum_{j\neq y_i} max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)
	\end{split}
    \end{equation} %]]></script>

<p>Though the expression seems complex, the interpretation is relatively simple. Firstly every class contribute to the loss of one sample, and the correct class doesn’t lead to loss. We want the correct class for sample <script type="math/tex">x_i</script> have a score <script type="math/tex">f(x_i, W)_{y_j}</script> higher than the incorrect classes <script type="math/tex">f(x_i, W)_j</script> by some fixed margin. If the incorrect class score adds some fix margin still less than correct class score, i.e., <script type="math/tex">% <![CDATA[
f(x_i, W)_j + \Delta < f(x_i, W)_{y_j} %]]></script>, then set the loss to be zero. Because the correct score is “much” big than than the incorrect scores, which we desire to achieve. However, if the the correct class score is not “big” enough or even less than the incorrect class scores, then we set the loss to be <script type="math/tex">f(x_i, W)_j + \Delta - f(x_i, W)_{y_j}</script>. Additionally the function max(0, -) is often called the <strong>hinge loss</strong>.</p>

<p>We still need regularization to our loss function. Suppose that we’ve got a set of weights <strong>W</strong> that can correctly classify all the samples, then the set of <strong>W</strong> is not necessarily unique. Firstly if we multiply a number <script type="math/tex">\lambda</script> <strong>W</strong>, then the decision boundary remains the same. So the scores stretches accordingly but the magin <script type="math/tex">\Delta</script> doesn’t change. Usually people add <script type="math/tex">L_2</script> regularization penalty <strong>R(W)</strong> to loss function.</p>

<script type="math/tex; mode=display">R(W) = \sum_k \sum_l W_{k, l}^2</script>

<p>So the full loss is as follows:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{equation}
     \begin{split}  
		L &= \frac{1}{m} \sum_i L_i + \lambda R(W) \\
		  &= \frac{1}{m} \sum_i \sum_{j \neq y_{y_i}} [max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)] + \lambda \sum_k \sum_l W_{k, l}^2
	\end{split}
    \end{equation} %]]></script>

<p>When <script type="math/tex">\lambda</script> is big, then <script type="math/tex">R(W) = \sum_k \sum_l W_{k, l}^2</script> is small. From binary SVM above, we know that the distance between one observation and the hyperplane of correct class is <script type="math/tex">\frac{f(x_i, W)_{y_j}} {\|w_{k}\|}</script>. therefore, the <script type="math/tex">L_2</script> penalty leads to the <strong>max margin</strong> property in SVMs and improve the generalization of the performance of the classifiers and avoid overfitting.</p>

<p>This loss function has no constrains and we can calculate the gradient and optimize the <strong>W</strong> using gradient descent algorithm.
For single example the SVM loss is:</p>

<script type="math/tex; mode=display">L_i = \sum_{j\neq y_i} max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)</script>

<p>We can differentiate the function with respect to weights. For <strong>w</strong> corresponding to the correct class:</p>

<script type="math/tex; mode=display">\nabla_{w_{y_i}} L_i = - \big(\sum_{y \neq y_i} \mathbb{1}(w_j^T x_i - w_{y_i}^T x_i + \Delta 0)\big) x_i</script>

<p>The gradient for incorrect class:</p>

<script type="math/tex; mode=display">\nabla_{w_j} L_i = \mathbb{1}(w_j^T x_i - w_{y_i}^T x_i + \Delta 0) x_i</script>

<p>where <script type="math/tex">\mathbb{1}</script> is the indicator function that is one if the condition is true or zero otherwise.</p>

<h2 id="get-your-hands-dirty-and-have-fun">7 Get your hands dirty and have fun</h2>
<ul>
  <li>Purpose: Implement multi-classification classifier.</li>
  <li>Data: CIFAR-10 dataset, consists of 60000 32x32 colour images in 10 classes, with 6000 images per class. There are 50000 training images and 10000 test images. The data is available <a href="http://www.cs.toronto.edu/~kriz/cifar.html">here</a>.</li>
  <li>Setup: I choose Python (IPython, numpy etc.) on Mac for implementation, and the results are published in a IPython notebook.</li>
  <li><a href="http://houxianxu.github.io/implementation/SVM.html">click here</a> for the implementation.</li>
  <li>Following is code to implement the logistic, one-vs-all and softmax classifiers by gradient decent algorithm.</li>
</ul>

<p><strong>classifiers: algorithms/classifiers.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">algorithms.classifiers.loss_grad_logistic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">algorithms.classifiers.loss_grad_softmax</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">algorithms.classifiers.loss_grad_svm</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">LinearClassifier</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># set up the weight matrix </span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'sgd'</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
              <span class="n">reg</span> <span class="o">=</span> <span class="mf">1e3</span><span class="p">,</span> <span class="n">num_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="s">"""
        Train linear classifer using batch gradient descent or stochastic gradient descent

        Parameters
        ----------
        X: (D x N) array of training data, each column is a training sample with D-dimension.
        y: (N, ) 1-dimension array of target data with length N.
        method: (string) determine whether using 'bgd' or 'sgd'.
        batch_size: (integer) number of training examples to use at each step.
        learning_rate: (float) learning rate for optimization.
        reg: (float) regularization strength for optimization.
        num_iters: (integer) number of steps to take when optimization.
        verbose: (boolean) if True, print out the progress (loss) when optimization.

        Returns
        -------
        losses_history: (list) of losses at each training iteration
        """</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_train</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">num_classes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># assume y takes values 0...K-1 where K is number of classes</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># initialize the weights with small values</span>
            <span class="k">if</span> <span class="n">num_classes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># just need weights for one class</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># weigths for each class</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>

        <span class="n">losses_history</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_iters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">'bgd'</span><span class="p">:</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># randomly choose a min-batch of samples</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">num_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">loss</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_grad</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="p">)</span> <span class="c"># grad =[K x D]</span>
            <span class="n">losses_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

            <span class="c"># update weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W</span> <span class="o">-=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span> <span class="c"># [K x D]</span>
            <span class="c"># print self.W</span>
            <span class="c"># print 'dsfad', grad.shape</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">print</span> <span class="s">'iteration </span><span class="si">%</span><span class="s">d/</span><span class="si">%</span><span class="s">d: loss </span><span class="si">%</span><span class="s">f'</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_iters</span><span class="p">,</span> <span class="n">loss</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">losses_history</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="s">"""
        Predict value of y using trained weights

        Parameters
        ----------
        X: (D x N) array of data, each column is a sample with D-dimension.

        Returns
        -------
        pred_ys: (N, ) 1-dimension array of y for N sampels
        h_x_mat: Normalized scores
        """</span>
        <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">f_x_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s">'Logistic'</span><span class="p">:</span>
            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">f_x_mat</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># multiclassification</span>
            <span class="n">pred_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">f_x_mat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># normalized score</span>
        <span class="n">h_x_mat</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">f_x_mat</span><span class="p">))</span> <span class="c"># [1, N]</span>
        <span class="n">h_x_mat</span> <span class="o">=</span> <span class="n">h_x_mat</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pred_ys</span><span class="p">,</span> <span class="n">h_x_mat</span>

    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="s">"""
        Compute the loss and gradients.

        Parameters
        ----------
        The same as self.train()

        Returns
        -------
        a tuple of two items (loss, grad)
        loss: (float)
        grad: (array) with respect to self.W
        """</span>
        <span class="k">pass</span>

<span class="c"># Subclasses of linear classifier</span>
<span class="k">class</span> <span class="nc">Logistic</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="s">"""A subclass for binary classification using logistic function"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loss_grad_logistic_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loss_grad_logistic_naive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Softmax</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="s">"""A subclass for multi-classicication using Softmax function"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loss_grad_softmax_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loss_grad_softmax_naive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SVM</span><span class="p">(</span><span class="n">LinearClassifier</span><span class="p">):</span>
    <span class="s">"""A subclass for multi-classicication using SVM function"""</span>
    <span class="k">def</span> <span class="nf">loss_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">loss_grad_svm_vectorized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span></code></pre></figure>

<p><strong>Function to compute loss and gradients for SVM classification: algorithms/classifiers/loss_grad_svm.py</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># file: algorithms/classifiers/loss_grad_svm.py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">loss_grad_svm_vectorized</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
    <span class="s">"""
    Compute the loss and gradients using softmax function 
    with loop, which is slow.

    Parameters
    ----------
    W: (K, D) array of weights, K is the number of classes and D is the dimension of one sample.
    X: (D, N) array of training data, each column is a training sample with D-dimension.
    y: (N, ) 1-dimension array of target data with length N with lables 0,1, ... K-1, for K classes
    reg: (float) regularization strength for optimization.

    Returns
    -------
    a tuple of two items (loss, grad)
    loss: (float)
    grad: (K, D) with respect to W
    """</span>

    <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="n">num_train</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># compute all scores</span>
    <span class="n">scores_mat</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="c"># [C x N] matrix</span>
 
    <span class="c"># get the correct class score </span>
    <span class="n">correct_class_score</span> <span class="o">=</span> <span class="n">scores_mat</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="c"># [1 x N]</span>
    
    <span class="n">margins_mat</span> <span class="o">=</span> <span class="n">scores_mat</span> <span class="o">-</span> <span class="n">correct_class_score</span> <span class="o">+</span> <span class="n">delta</span> <span class="c"># [C x N]</span>

    <span class="c"># set the negative score to be 0</span>
    <span class="n">margins_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">margins_mat</span><span class="p">)</span>
    <span class="n">margins_mat</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">margins_mat</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_train</span>

    <span class="c"># add regularization to loss</span>
    <span class="n">loss</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>

    <span class="c"># compute gradient</span>
    <span class="n">scores_mat_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">scores_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># compute the number of margin 0 for each sample</span>
    <span class="n">num_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">margins_mat</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">scores_mat_grad</span><span class="p">[</span><span class="n">margins_mat</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">scores_mat_grad</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_train</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">num_pos</span>

    <span class="c"># compute dW</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">scores_mat_grad</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_train</span> <span class="o">+</span> <span class="n">reg</span> <span class="o">*</span> <span class="n">W</span>
    
    <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">dW</span></code></pre></figure>

<h2 id="reference-and-further-reading">11. Reference and further reading</h2>
<ul>
  <li>Andrew Ng’s <a href="https://www.coursera.org/course/ml">Machine learning on Coursera</a></li>
  <li>Machine learing notes on <a href="http://see.stanford.edu/materials/aimlcs229/cs229-notes3.pdf">Stanford Engineering Everywhere (SEE)</a></li>
  <li>Stanford University open course <a href="http://vision.stanford.edu/teaching/cs231n/">CS231n</a></li>
  <li>The University of Nottingham <a href="http://modulecatalogue.nottingham.ac.uk/Nottingham/asp/moduledetails.asp?year_id=000113&amp;crs_id=021211">Machine Learning Module</a></li>
</ul>

<!-- ## New idea:
- asymmetric prediction, max margins for two classes are different.
- Two mimimal margin classifier
 -->


  </article>

  <!-- mathjax -->
  
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  
  <!-- disqus comments -->
 
 <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'houxianxu'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  
  
</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <!-- <h2 class="footer-heading">Xianxu Hou's blog</h2> -->

    <div class="footer-col-1 column">
      <ul>
        <li>Xianxu Hou's blog</li>
        <!-- <li><a href="mailto:"></a></li> -->
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/houxianxu">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username">houxianxu</span>
          </a>
        </li>
        
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">From Coal Mining to Data Mining</p>
    </div>

  </div>

</footer>


    </body>
</html>